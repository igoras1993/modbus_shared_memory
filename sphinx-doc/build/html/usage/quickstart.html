
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Quickstart &#8212; Modbus Shared Memory 1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory mapping" href="Memory mapping.html" />
    <link rel="prev" title="Installation" href="Instalation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="quickstart">
<h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">Â¶</a></h1>
<p>We showed you sample MSM client (master) usage at the <a class="reference internal" href="../index.html#index-sample-label"><span class="std std-ref">main page</span></a>. However, to run such code
properly, you first need a working modbus server (slave) at your <em>localhost</em>. Because of that, we will first create
a sample modbus server with some neet memory mapping. Next, we will create a client talking to the server.</p>
<dl class="simple">
<dt>The code below will:</dt><dd><ul class="simple">
<li><p>allocate 16 bytes of memory</p></li>
<li><p>define some variables on this memory</p></li>
<li><p>start modbus TCP server worker</p></li>
<li><p>present those variables in cli</p></li>
</ul>
</dd>
</dl>
<p id="modbus-server-example">ex_server_mapper.py</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ModbusSharedMemory.client_server</span> <span class="k">import</span> <span class="n">ModbusSlaveTCP</span>
<span class="kn">from</span> <span class="nn">ModbusSharedMemory.memory</span> <span class="k">import</span> <span class="n">MemoryStore</span><span class="p">,</span> <span class="n">MemoryVariable</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="k">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">choice</span> <span class="k">as</span> <span class="n">random_choice</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">platform</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">sleep</span>

<span class="k">def</span> <span class="nf">clear</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span> <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span> <span class="k">else</span> <span class="s1">&#39;clear&#39;</span><span class="p">)</span>


<span class="c1"># declare memory, 8 words = 16 bytes</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">MemoryStore</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># declare some mappings</span>
<span class="c1"># name it as u wish</span>
<span class="c1"># e.g. PLC like naming convention</span>

<span class="c1"># those variables lays in memory in following places: </span>
<span class="c1"># ( &quot;_&quot; indicates variable place, </span>
<span class="c1">#  &quot;(WW)&quot; represents one word, </span>
<span class="c1"># &quot;bx&quot; represents x-th bit of that word): </span>

<span class="c1">#  _</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">WORK_MODE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 8 bit long</span>

<span class="c1">#   _</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">PROCESS_STEP</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 8 bit long</span>

<span class="c1">#      __  __</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">CURRENT_VALUE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this one takes 32 bits = 4 bytes = 2 words, </span>
                                                     <span class="c1"># declare next variable at add&gt;=3 or they </span>
                                                     <span class="c1"># will overlap</span>

<span class="c1">#              __</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">CONTROL_WORD</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">word</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># this takes 16 bits = 2bytes = 1 word</span>

<span class="c1">#              b0</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">bool</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bit_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># we can overlap by intention, </span>
                                                               <span class="c1"># playing with word bits</span>

<span class="c1"># enough, start the server</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">ModbusSlaveTCP</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="c1"># new server</span>
<span class="n">server</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>                 <span class="c1"># run at another thread</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># simple debug screen</span>
    <span class="n">run</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">run</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clear</span><span class="p">()</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                WORK_MODE: </span><span class="si">{0}</span><span class="s2">,</span>
<span class="s2">                PROCESS_STEP: </span><span class="si">{1}</span><span class="s2">,</span>
<span class="s2">                CURRENT_VALUE: </span><span class="si">{2}</span><span class="s2">,</span>
<span class="s2">                CONTROL_WORD: </span><span class="si">{3}</span><span class="s2">,</span>
<span class="s2">                ERROR_STATE: </span><span class="si">{4}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">WORK_MODE</span><span class="p">,</span> 
                <span class="n">mem</span><span class="o">.</span><span class="n">PROCESS_STEP</span><span class="p">,</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">CURRENT_VALUE</span><span class="p">,</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">CONTROL_WORD</span><span class="p">,</span>
                <span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span><span class="p">))</span>
            
            <span class="c1"># we can also modify some values, client will see this changes, it is that simple</span>
            <span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span> <span class="o">=</span> <span class="n">random_choice</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="n">run</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">server</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>Whole advantage of using MSM as your modbus backend comes from two things:</dt><dd><ul class="simple">
<li><p>You are not using modbus functions directly, instead you use <em>memory variables</em> like ordinary python variables</p></li>
<li><p>You dont bother yourself with serving modbus server/client by yourself, instead, you just instantiating it and tells it to <em>run</em></p></li>
</ul>
</dd>
</dl>
<p>Server code will pretty print declared <em>memory variables</em> to show its content. Especially it will show changes while you
will be altering them as a client, and it will periodically alter <strong>ERROR_STATE</strong> variable to show you that you can see this changes from
the client side. Lets now write some code for the client:</p>
<p id="modbus-client-example">ex_client_mapper.py</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ModbusSharedMemory.client_server</span> <span class="k">import</span> <span class="n">ModbusMasterTCP</span>
<span class="kn">from</span> <span class="nn">ModbusSharedMemory.memory</span> <span class="k">import</span> <span class="n">MemoryStore</span><span class="p">,</span> <span class="n">MemoryVariable</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="k">import</span> <span class="n">dedent</span>


<span class="k">def</span> <span class="nf">print_variables</span><span class="p">(</span><span class="n">memory</span><span class="p">):</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                WORK_MODE: </span><span class="si">{0}</span><span class="s2">,</span>
<span class="s2">                PROCESS_STEP: </span><span class="si">{1}</span><span class="s2">,</span>
<span class="s2">                CURRENT_VALUE: </span><span class="si">{2}</span><span class="s2">,</span>
<span class="s2">                CONTROL_WORD: </span><span class="si">{3}</span><span class="s2">,</span>
<span class="s2">                ERROR_STATE: </span><span class="si">{4}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">WORK_MODE</span><span class="p">,</span> 
        <span class="n">memory</span><span class="o">.</span><span class="n">PROCESS_STEP</span><span class="p">,</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">CURRENT_VALUE</span><span class="p">,</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">CONTROL_WORD</span><span class="p">,</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">ERROR_STATE</span><span class="p">))</span>


<span class="c1"># declare mappings, preferd is to have same mapping on server and client side</span>
<span class="c1"># but it is your choice. Excange is done by addresses.</span>

<span class="c1"># declare memory, 8 words = 16 bytes</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">MemoryStore</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># declare some mappings</span>
<span class="c1"># name it as u wish</span>
<span class="c1"># e.g. PLC like naming convention</span>

<span class="c1"># those variables lays in memory in following places: </span>
<span class="c1"># ( &quot;_&quot; indicates variable place, </span>
<span class="c1">#  &quot;(WW)&quot; represents one word, </span>
<span class="c1">#  &quot;bx&quot; represents x-th bit of that word): </span>

<span class="c1">#  _</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">WORK_MODE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 8 bit long</span>

<span class="c1">#   _</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">PROCESS_STEP</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 8 bit long</span>

<span class="c1">#      __  __</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">CURRENT_VALUE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this one takes 32 bits = 4 bytes = 2 words, </span>
                                                     <span class="c1"># declare next variable at add&gt;=3 or they </span>
                                                     <span class="c1"># will overlap</span>

<span class="c1">#              __</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">CONTROL_WORD</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">word</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># this takes 16 bits = 2bytes = 1 word</span>

<span class="c1">#              b0</span>
<span class="c1"># (WW)(WW)(WW)(WW)(WW)(WW)(WW)(WW)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">bool</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bit_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># we can overlap by intention, </span>
                                                               <span class="c1"># playing with word bits</span>

<span class="c1"># enough, declare client</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">ModbusMasterTCP</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">client</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="c1"># run client exchange service in another thread</span>

<span class="c1"># now do what u want with memory</span>
<span class="c1"># if u import this file, u can play with variables, remember to kill client at the end! </span>
<span class="c1"># client.kill()</span>
<span class="c1"># if u run this file, program will do some actions procedural actions</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">mem</span><span class="o">.</span><span class="n">WORK_MODE</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">print_variables</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">mem</span><span class="o">.</span><span class="n">PROCESS_STEP</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">print_variables</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">mem</span><span class="o">.</span><span class="n">CURRENT_VALUE</span> <span class="o">=</span> <span class="mi">99999</span>
    <span class="n">print_variables</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">mem</span><span class="o">.</span><span class="n">CONTROL_WORD</span> <span class="o">=</span> <span class="mb">0b1000000000000000</span>
    <span class="n">print_variables</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">client</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
</pre></div>
</div>
<p>Now you can run server code in terminal window. It will run until you terminate it (CTRL+C). Next, in another terminal,
you can run a client code. You should see how values are changing on server side, just by writing memory variables on the
client side. You can terminate client application by pressing CTRL+C.</p>
<p>Also, you can import client code to play with memory variables by yourself. Open python interactive shell:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ex_client_mapper</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># read ERROR_STATE variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># read it again and you will likely see other value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because server constanly alters this variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mem</span><span class="o">.</span><span class="n">ERROR_STATE</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># write a value to CONTROL_WORD and watch server side</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span><span class="o">.</span><span class="n">CONTROL_WORD</span> <span class="o">=</span> <span class="mi">25</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># kill the worker when you are done</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>Now, when you are more familiar with MSM, we can emphasize some notes:</p>
<blockquote>
<div><ol class="arabic">
<li><p><strong>Memory variables are customizable</strong>
You declare them on <em>MemoryStore</em> instance using special methods of <em>MemoryVariable</em> class, and you can give them any name:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mem</span><span class="o">.</span><span class="n">SOME_REALY_STRANGE_NAME</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><strong>Memory variables have addresses</strong>
It mean that you can declare two diferent variables, that will overlay. Changing the one will impact the other.
Doing so sounds strange, but it sometimes has a reason.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span><span class="o">.</span><span class="n">ONE_VARIABLE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span><span class="o">.</span><span class="n">OTHER_VARIABLE</span> <span class="o">=</span> <span class="n">MemoryVariable</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">byte_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span><span class="o">.</span><span class="n">ONE_VARIABLE</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mem</span><span class="o">.</span><span class="n">OTHER_VARIABLE</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Those above share their address, one is always equal to other and vice versa.</p>
</li>
<li><p><strong>It is memory what is exchanged, not variables</strong>
Variables only reflects state of memory. You can declare two variables on one address, or do not declare variables
at all. Memory still will be exchanged. You can even declare variable later on, and it will still reflect memory
state itâs pointing on.</p></li>
<li><p><strong>Memory space is Word-numbered</strong>
Modbus protocol defines holding registers to store 16-bit values. Since we want to be consistent with this standard,
all addresses are considered to point on 16-bit values (Words).</p></li>
<li><p><strong>Client and server runs in separate threads</strong>
We decided to delegate client/server workers in threads. Those are daemon threds and are started when <em>.run()</em> method
is called. They should be properly closed, <em>.kill()</em> method serves that purpose. Care to call it when you are
done with modbus communication.</p></li>
</ol>
</div></blockquote>
<p>You see all this facts in given examples. Both: server and client declares exactly the same memory mapping,
but they could do it in a different way - however this would mess up code logic,
but it will work. <strong>It is memory what is exchanged, not variables</strong>. Also, comments in code presents you that
<strong>memory space is word-numbered</strong>, every register holds 16-bit value. All of this registers <strong>have address</strong>.</p>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Modbus Shared Memory</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Instalation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="Client and server.html">Client and server</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Instalation.html" title="previous chapter">Installation</a></li>
      <li>Next: <a href="Memory mapping.html" title="next chapter">Memory mapping</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, igoras1993.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/usage/Quickstart.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>